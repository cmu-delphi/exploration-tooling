---
title: Baseline Forecaster Fan Plots 2024-2025
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
params:
  disease: "flu"
editor_options:
  chunk_output_type: console
---

$$\\[.4in]$$

```{r echo=FALSE}
knitr::opts_chunk$set(
    fig.align = "center",
    message = FALSE,
    warning = FALSE,
    cache = FALSE
)
knitr::opts_knit$set(root.dir = here::here())
ggplot2::theme_set(ggplot2::theme_bw())
```

# Linear Extrapolation Model for `r params$disease`

Simple model:

- For each geo, replace zero weeks with NA and then forward fill.
- For each geo, regress the log of the last few weeks (population scaled) on the week number.
- Predict the aheads for each geo.
- Any location that had fewer than 2 recent non-zero weeks gets the pop-scaled median (or mean) as their point forecast.
- Use pooled residuals to get PIs for everything and then resample for future aheads.
- Get back to the original scale.

```{r}
# params <- list(disease = "flu")
source("R/load_all.R")
library(ggplot2)
library(plotly)

if (params$disease == "flu") {
    epi_data <- readr::read_csv("https://data.cdc.gov/resource/ua7e-t2fy.csv?$limit=20000&$select=weekendingdate,jurisdiction,totalconfflunewadm") %>%
        rename(time_value = weekendingdate, value = totalconfflunewadm, geo_value = jurisdiction)
} else if (params$disease == "covid") {
    epi_data <- readr::read_csv("https://data.cdc.gov/resource/ua7e-t2fy.csv?$limit=20000&$select=weekendingdate,jurisdiction,totalconfc19newadm") %>%
        rename(time_value = weekendingdate, value = totalconfc19newadm, geo_value = jurisdiction)
} else {
    stop("Invalid disease")
}
epi_data <- epi_data %>%
    filter(geo_value %nin% c("AS", "USA", "VI", "PR", "MP", "GU")) %>%
    mutate(time_value = as.Date(time_value), geo_value = tolower(geo_value))

forecast_date <- max(epi_data$time_value)
subset_geos <- epi_data$geo_value %>% unique()
# subset_geos <- c("ca", "ny", "fl", "tx", "pa")
quantile_forecast <- forecaster_baseline_linear(epi_data) %>% filter(geo_value %in% subset_geos)
truth_data <- epi_data %>%
    mutate(forecaster = "", target_end_date = time_value) %>%
    filter(geo_value %in% subset_geos, time_value > forecast_date - 90, time_value <= forecast_date - 30)

# TODO: Train data in black
p <- plot_forecasts(quantile_forecast, forecast_date, geo_type = "state", truth_data = truth_data) +
    geom_line(
        data = epi_data %>%
            mutate(forecaster = "", target_end_date = time_value) %>%
            filter(geo_value %in% subset_geos, time_value > forecast_date - 30),
        aes(x = time_value, y = value),
        color = "black"
    )
p
ggplotly(p, tooltip = "text", height = 5000, width = 1700)
```
