---
title: "`r params$disease` `r params$target` score report"
author: Delphi Forecast Team
date: "Rendered: `r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    code_folding: hide
    toc: True
    fig_crop: no
    # self_contained: False
    # lib_dir: libs
params:
  disease: "covid"
  target: ""
  archive: ""
  scores: ""
  external_forecasts: ""
---

```{css, echo=FALSE}
img {
  max-width:125%;
  height:auto;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
ggplot2::theme_set(ggplot2::theme_bw())
options(width=500)
library(ggnewscale)
recent_archive <- params$archive
if (params$target == "nssp") {
  recent_archive$DT <- rename(recent_archive$DT, value = nssp)
}
this_week <- round_date(Sys.Date() - 3, "week", 6)
## suppressPackageStartupMessages(source("R/load_all.R"))
## params <- list()
## params$external_forecasts <- qs2::qs_read(here::here("flu_hosp_prod", "objects", "external_forecasts_full")) %>% select(-target)
## params$archive <- qs2::qs_read(here::here("flu_hosp_prod", "objects", "nhsn_archive_data"))
## params$scores <- qs2::qs_read(here::here("flu_hosp_prod", "objects", "external_scores_nhsn_full"))
```

# Recent scores {.tabset}

```{r adjusting data, echo=FALSE, message=FALSE}
forecasts <- params$external_forecasts
our_forecasters <- c("linear", "windowed_seasonal", "windowed_seasonal_nssp", "climate_base", "climate_geo_agged", "climate_linear", "ensemble_windowed", "retro_submission", "CMU-TimeSeries", "seasonal_nssp_latest")
scores <- params$scores %>%
  mutate(
    forecaster =
      case_match(
        forecaster,
        "windowed_seasonal_extra_sources" ~ "windowed_seasonal_nssp",
        "ensemble_linclim_windowed_seasonal" ~ "retro_submission",
        "ens_ar_only" ~ "ensemble_windowed",
        .default = forecaster
      )) %>%
  left_join(state_census, by = join_by(geo_value == abbr)) %>%
  mutate(wis_rate = wis * 1e5 / pop) %>%
  mutate(ae_rate = ae_median * 1e5 / pop) %>%
  mutate(pop = factor(pop))
Mean <- function(x) mean(x, na.rm = TRUE)
GeoMean <- function(x, offset = 0) exp(Mean(log(x + offset)))
```

```{r score_summary_functions, echo=FALSE, message=FALSE}
scores_by_state <- function(scores) {
  scores %>%
    group_by(forecaster, geo_value) %>%
    summarize(
      mean_wis = Mean(wis),
      geo_mean_wis = GeoMean(wis),
      mean_ae = Mean(ae_median),
      geomean_ae = GeoMean(ae_median),
      mean_wis_rate = Mean(wis_rate),
      geo_mean_wis_rate = GeoMean(wis_rate),
      mean_ae_rate = Mean(ae_rate),
      geomean_ae_rate = GeoMean(ae_rate),
      .groups = "drop"
    ) %>%
    arrange(forecaster, mean_wis_rate)
}
scores_by_ahead <- function(scores) {
  forecast_date <- scores %>%
    distinct(forecast_date) %>%
    pull() %>%
    max()
  scores %>%
    group_by(forecaster, ahead) %>%
    summarize(
      mean_wis = Mean(wis),
      geo_mean_wis = GeoMean(wis),
      mean_ae = Mean(ae_median),
      geomean_ae = GeoMean(ae_median),
      mean_wis_rate = Mean(wis_rate),
      geo_mean_wis_rate = GeoMean(wis_rate),
      mean_ae_rate = Mean(ae_rate),
      geomean_ae_rate = GeoMean(ae_rate),
      .groups = "drop"
    ) %>%
    arrange(ahead, forecaster, mean_wis_rate) %>%
    mutate(forecast_date = .env$forecast_date)
}
se_mean_states <- function(scores) {
  scores_by_state(scores) %>%
    group_by(forecaster) %>%
    summarize(
      se_mean_wis = sd(mean_wis, na.rm = TRUE) / sqrt(n()),
      se_geomean_wis = sd(geo_mean_wis, na.rm = TRUE) / sqrt(n()),
      se_mean_ae = sd(mean_ae, na.rm = TRUE) / sqrt(n()),
      se_geomean_ae = sd(geomean_ae, na.rm = TRUE) / sqrt(n()),
      se_mean_wis_rate = sd(mean_wis_rate, na.rm = TRUE) / sqrt(n()),
      se_geomean_wis_rate = sd(geo_mean_wis_rate, na.rm = TRUE) / sqrt(n()),
      se_mean_ae_rate = sd(mean_ae_rate, na.rm = TRUE) / sqrt(n()),
      se_geomean_ae_rate = sd(geomean_ae_rate, na.rm = TRUE) / sqrt(n()),
      .groups = "drop"
    ) %>%
    mutate(across(starts_with("se"), \(x) round(x, 2)))
}
score_summary <- function(scores) {
  forecast_date <- scores %>%
    distinct(forecast_date) %>%
    pull() %>%
    max()
  scores %>%
    group_by(forecaster) %>%
    mutate(
      min_wis = min(wis[wis > 1e-5]),
      min_ae = min(ae_median[ae_median > 1e-5])
    ) %>%
    summarize(
      mean_wis = round(Mean(wis), 2),
      mean_wis_rate = round(Mean(wis_rate), 2),
      geomean_wis = round(GeoMean(wis, min_wis), 2),
      mean_ae = round(Mean(ae_median), 2),
      mean_ae_rate = round(Mean(ae_rate), 2),
      geomean_ae = round(GeoMean(ae_median, min_ae), 2),
      mean_cov_50 = round(Mean(interval_coverage_50), 2),
      mean_cov_90 = round(Mean(interval_coverage_90), 2),
      n = n(),
      .groups = "drop"
    ) %>%
    left_join(se_mean_states(scores), by = "forecaster") %>%
    arrange(mean_wis) %>%
    select(forecaster, mean_wis, se_mean_wis, mean_wis_rate, se_mean_wis_rate, mean_cov_50, mean_cov_90, geomean_wis) %>%
    mutate(forecast_date = .env$forecast_date)
}
datatable_function <- function(score_summary) {
  datatable(
    score_summary,
    fillContainer = FALSE,
    options = list(
      initComplete = htmlwidgets::JS(
        "function(settings, json) {",
        paste0("$(this.api().table().container()).css({'font-size': '", "10pt", "'});"),
        "}"),
      pageLength = 25
    )
  ) %>%
    formatStyle("forecaster", target = c("cell"),
                textDecoration = styleEqual("CMU-TimeSeries", "underline")) %>%
    formatStyle(
      "mean_wis",
      background = styleColorBar(c(0, max(score_summary$mean_wis)), 'lightblue'),
      backgroundSize = '98% 88%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ) %>%
    formatStyle(
      "mean_wis_rate",
      background = styleColorBar(c(0, max(score_summary$mean_wis_rate)), 'lightblue'),
      backgroundSize = '98% 88%',
      backgroundRepeat = 'no-repeat',
      backgroundPosition = 'center'
    ) %>%
    formatStyle(
    "geomean_wis",
    backgroundound = styleColorBar(c(0, max(score_summary$geomean_wis)), 'lightblue'),
    backgroundSize = '98% 88%',
    backgroundRepeat = 'no-repeat',
    backgroundPosition = 'center'
    )
}
```

## Last 8 weeks

```{r datatable_short, out.width= "100%", fig.height = 60, fig.width = 12, echo=FALSE, message=FALSE}
score_summary_8 <- scores %>%
  filter(forecast_date >= this_week - 8 * 7) %>%
  score_summary()
datatable_function(score_summary_8)
```

## Last 4 weeks

```{r datatable_shortest, out.width= "100%", fig.height = 60, fig.width = 12, echo=FALSE, message=FALSE}
score_summary_short <- scores %>%
  filter(forecast_date > this_week - 4 * 7) %>%
  score_summary()
datatable_function(score_summary_short)
```

## Last 52 weeks
```{r datatable_long, fig.height = 60, fig.width = 12, echo=FALSE, message=FALSE}
score_summary_long <- scores %>%
  filter(forecast_date > this_week - 52 * 7) %>%
  score_summary()
datatable_function(score_summary_long)
```

# Moving 8 week average of scores{.tabset}

```{r moving_average, echo=FALSE, message=FALSE, include=FALSE}
date_range <- scores %>% distinct(forecast_date) %>% pull() %>% range()
all_forecasters_dates <- crossing(
  forecaster = scores %>% distinct(forecaster) %>% pull(),
  forecast_date = seq.Date(date_range[1], date_range[2], by = 7)
  )
ordered_scores <- scores %>%
  full_join(
    all_forecasters_dates,
    by = join_by(forecaster, forecast_date), 
  ) %>%
  arrange(forecast_date)
sliding_ordered <- ordered_scores %>%
  slide_index_dfr(
    .i = ordered_scores$forecast_date,
    .f = score_summary,
    .before = lubridate::weeks(7),
    .complete = TRUE
  ) %>%
  group_by(forecaster, forecast_date) %>%
  slice(1)
baseline_only <- sliding_ordered %>% filter(forecaster == "CovidHub-baseline")
sliding_ordered <- sliding_ordered %>%
  group_by(forecast_date) %>%
  left_join(baseline_only, by = "forecast_date", suffix = c("", ".baseline")) %>%
  mutate(
    rel_mean_wis = mean_wis / mean_wis.baseline,
    rel_mean_wis_rate = mean_wis_rate / mean_wis_rate.baseline,
  )

plotted_forecasters <- sliding_ordered %>% ungroup() %>% distinct(forecaster) %>% pull(forecaster) %>% sort()
top_5_and_CMU <- score_summary_short %>%
  pull(forecaster) %>%
  `[`(1:5) %>%
  append("CMU-TimeSeries") %>%
  unique()
start_hidden <- setdiff(plotted_forecasters, top_5_and_CMU)

plotting_score <- function(sliding_plot, score_to_plot) {
  resulting_plot <- sliding_plot %>%
    ggplot(aes(x = forecast_date, y = {{ score_to_plot }}, color = forecaster, linewidth = ifelse(forecaster == "CMU-TimeSeries", 1, 0.5))) +
    geom_line() +
    scale_color_viridis_d(option = "turbo") +
    scale_y_continuous(breaks = breaks_pretty(n = 20), limits = c(0, NA)) +
    scale_x_date(breaks = "1 month", date_labels = "%b\n%Y") +
    scale_linewidth(range = c(.5, 1.5)) +
    guides(linewidth = "none")
  resulting_plot
}
gplot <- function(resulting_plot, height = 600, width = 1000) {
  plotly_plot <- ggplotly(resulting_plot, tooltip = "text", height = height, width = width) 
  for (i in seq_along(plotly_plot$x$data)) {
    data_row <- plotly_plot$x$data[i]
    if (data_row[[1]]$name %in% start_hidden) {
      plotly_plot$x$data[[i]]$visible <- "legendonly"
    }
  }
  plotly_plot %>%
    layout(hoverlabel = list(bgcolor = "white"), yaxis = list(rangemode = "tozero", autorange = TRUE), xaxis = list(autorange = TRUE))
}
```

## Mean WIS

```{r moving_average_wis, echo=FALSE, message=FALSE, out.width="100%"}
plotting_score(sliding_ordered, mean_wis) %>% gplot()
```
## Relative Mean WIS

```{r moving_average_rel_wis, echo=FALSE, message=FALSE, out.width="100%"}
plot_rel_mean <- plotting_score(sliding_ordered, rel_mean_wis) +
  geom_hline(aes(yintercept = 1), color="black", linetype = "dashed")
plot_rel_mean %>% gplot()
```

<!-- only including the per capita WIS for nhsn -->

```{r}
if (params$target == "nhsn") {
  scaled_WIS_plot <- knitr::knit_expand(
                    text = c(
                      "## Mean WIS per capita\n",
                      "\n",
                      "```{r moving_average_wis_rate, echo=FALSE, message=FALSE, out.width='100%'}\n",
                      "plotting_score(sliding_ordered, mean_wis_rate) %>% gplot()\n",
                      "```\n",
                      "\n")
                  )
 plot2 <- knitr::knit_expand(
                 text = c(
                   "## All by WIS per capita\n",
                   "```{r plotting_all_recent_forecasts, out.width='300%', fig.dim=c(12,60), fig.align = 'center', message=FALSE, eval = params$target == 'nhsn'}\n",
                   "plotting_forecasts(plotting_window = this_week - 12 * 7, score_window = 8, geo_score_rate_order, n_plotting = 60)\n",
                   "```\n",
                   "\n"
                 )) 
}
```
`r if (params$target == "nhsn") {knitr::knit(text = scaled_WIS_plot)}`
## Mean Coverage 90

```{r moving_average_cov90, echo=FALSE, message=FALSE, out.width="100%"}
cov_plot <- plotting_score(sliding_ordered, mean_cov_90) +
  scale_y_continuous(breaks = breaks_pretty(n = 20), limits = c(0, 1)) +
  geom_hline(aes(yintercept = 0.90), color="black", linetype = "dashed") 
gplot(cov_plot)
```

## Mean Coverage 50

```{r moving_average_cov50, echo=FALSE, message=FALSE, out.width="100%"}
cov_plot <- plotting_score(sliding_ordered, mean_cov_50) + 
  scale_y_continuous(breaks = breaks_pretty(n = 20), limits = c(0, 1)) +
  geom_hline(aes(yintercept = 0.50), color="black", linetype = "dashed")
gplot(cov_plot)
```

## 8 week moving average scores by ahead

```{r calculate_scores_by_ahead, echo=FALSE, message=FALSE, include = FALSE}
scores %>% scores_by_ahead()
sliding_ahead_ordered <- ordered_scores %>%
  slide_index_dfr(
    .i = ordered_scores$forecast_date,
    .f = scores_by_ahead,
    .before = lubridate::weeks(8),
    .complete = TRUE
  ) %>%
  group_by(forecaster, forecast_date, ahead) %>%
  slice(1)
```

```{r ahead_plot_wis, echo=FALSE, message=FALSE, out.width="100%"}
ahead_wis_plot <- plotting_score(sliding_ahead_ordered, mean_wis) +
    facet_grid(rows = "ahead")
ahead_wis_plot %>% gplot(height = 1200)
```
# Large recent data revisions {.tabset}

```{r revisions, echo=FALSE, message=FALSE, out.width="100%"}
recent_archive <- recent_archive %>%
  filter(this_week - time_value < 10*7)
recent_archive$time_type <- "day"
revision_sum <- recent_archive %>%
  epiprocess::revision_analysis(value, min_waiting_period = NULL)
av_re_spread <- revision_sum$revision_behavior %>%
  group_by(geo_value) %>%
  summarize(rel_spread = mean(rel_spread, na.rm = TRUE)) %>%
  arrange(desc(rel_spread)) %>%
  filter(geo_value %nin% c("vi", "as", "gu"))
worst_geos <- av_re_spread %>% pull(geo_value)
worst_geos <- worst_geos[1:9]
filtered_archive <- recent_archive %>%
  filter(geo_value %in% worst_geos) %>%
  filter(time_value >= "2024-11-19")
filtered_archive$DT %<>%
  mutate(geo_value = factor(geo_value, levels = av_re_spread$geo_value[1:18]))
```

## Large Mean Revision
The states most likely to be subject to total revisions requiring substitution.

```{r revision_plots, fig.width = 15, fig.height = 10, fig.align = "center", echo=FALSE}
autoplot(filtered_archive, "value") +
  facet_wrap(~geo_value, ncol = 3, scales = "free") +
  theme(strip.text.x = element_text(size = 8)) +
  ylim(0, NA) +
  labs(title = "States with the largest mean revision")
```


## All revisions
```{r all_revision_plots, out.width="120%", fig.width = 15, fig.height = 60, fig.align = "center"}
recent_archive$DT %<>% mutate(geo_value = factor(geo_value, levels = av_re_spread$geo_value))
recent_archive %>%
  autoplot("value") +
  facet_wrap(~geo_value, ncol = 3, scales = "free") +
  theme(strip.text.x = element_text(size = 8)) +
  ylim(0, NA) +
  labs(title = "States with the largest mean revision")
```

# Forecasts from 8 weeks ago, sorted by decreasing recent WIS {.tabset}
Plotting the forecasts from 8 weeks ago until 3 weeks ago for each geography, sorted by WIS or population scaled WIS.
```{r plotting_recent_forecasts_function, echo=FALSE, message=FALSE}
plotting_forecasts <- function(plotting_window, score_window, geo_score_order, n_plotting) {
  geo_score_order_2 <- geo_score_order[1:n_plotting]
  plotting_archive <- recent_archive
  plotting_archive$DT %<>%
    filter(geo_value %in% geo_score_order_2, time_value > plotting_window) %>%
    mutate(geo_value = factor(geo_value, levels = geo_score_order_2))
  if (params$target == "nhsn") {
    plotting_archive$DT %<>%
    left_join(state_census, by = join_by(geo_value == abbr)) %>%
    mutate(value = value * 1e5/ pop) %>%
    select(-pop)
  } else {
    forecasts %<>%
      mutate(
        value = value * 100
      )
  }
  latest_data_date <- plotting_archive$DT %>% pull(time_value) %>% max()
  forecasts_to_plot <- forecasts %>%
    filter(
      forecaster == "CMU-TimeSeries",
      geo_value %in% geo_score_order_2,
      forecast_date > this_week - score_window * 7
    ) %>%
    mutate(
      geo_value = factor(geo_value, levels = geo_score_order_2),
      forecast_date = factor(forecast_date)
    ) %>%
    ungroup()
  if (params$target == "nhsn") {
    forecasts_to_plot %<>%
      left_join(state_census, by = join_by(geo_value == abbr)) %>%
      mutate(value = value * 1e5/ pop)
  }
  forecasts_to_plot %<>%
    pivot_wider(names_from = quantile, values_from = value) %>%
    mutate(time_value = target_end_date)
  plotting_archive %>%
    autoplot() +
    new_scale_color() +
    geom_ribbon(data = forecasts_to_plot, aes(ymin = `0.25`, ymax = `0.75`, fill = forecaster, group = forecast_date), alpha = 0.4) +
    geom_ribbon(data = forecasts_to_plot, aes(ymin = `0.1`, ymax = `0.9`, fill = forecaster, group = forecast_date), alpha = 0.4) +
    geom_ribbon(data = forecasts_to_plot, aes(ymin = `0.05`, ymax = `0.95`, fill = forecaster, group = forecast_date), alpha = 0.4) +
    geom_line(data = forecasts_to_plot, aes(y = `0.5`, group = forecast_date), alpha = 0.4) +
    scale_color_brewer(palette = "Set3") +
    scale_fill_brewer(palette = "Set3") +
    facet_grid(factor(geo_value, levels = geo_score_order_2) ~ forecast_date, scale = if(n_plotting>20) "free" else "fixed") +
    scale_y_continuous(breaks = breaks_pretty(n = 5), limits = c(0, NA)) +
    scale_x_date(breaks = "14 days", date_labels = "%d\n%b", sec.axis = sec_axis(~ ., name = "Forecast Date", breaks = NULL, labels = NULL))
}
score_window <- 8
geo_score_rate_order <- scores %>%
  filter(forecast_date > this_week - score_window * 7) %>%
  scores_by_state() %>%
  filter(forecaster == "CMU-TimeSeries") %>%
  arrange(desc(mean_wis_rate)) %>% pull(geo_value)
```
<!-- include rates if we're plotting nhsn only -->
```{r} 
if (params$target == "nhsn") {
  plot1 <- knitr::knit_expand(
                    text = c(
                      "## Worst 5 by WIS per capita\n",
                      "```{r plotting_recent_forecasts, out.width='300%', fig.dim=c(10,5), fig.align = 'center', echo=FALSE, message=FALSE, eval = params$target == 'nhsn'}\n",
                      "plotting_forecasts(plotting_window = this_week - 12 * 7, score_window = 8, geo_score_rate_order, n_plotting = 5)\n",
                      "```\n",
                      "\n")
                  )
 plot2 <- knitr::knit_expand(
                 text = c(
                   "## All by WIS per capita\n",
                   "```{r plotting_all_recent_forecasts, out.width='300%', fig.dim=c(12,60), fig.align = 'center', message=FALSE, eval = params$target == 'nhsn'}\n",
                   "plotting_forecasts(plotting_window = this_week - 12 * 7, score_window = 8, geo_score_rate_order, n_plotting = 60)\n",
                   "```\n",
                   "\n"
                 )) 
}
```
`r if (params$target == "nhsn") {knitr::knit(text = plot1)}`

`r if (params$target == "nhsn") {knitr::knit(text = plot2)}`


## Worst 5 by WIS
```{r plotting_raw_wis_recent_forecasts, out.width="300%", fig.dim=c(10,5), fig.align = "center", echo=FALSE, message=FALSE}
score_window <- 8
geo_score_order <- scores %>%
  filter(forecast_date > this_week - score_window * 7) %>%
  scores_by_state() %>%
  filter(forecaster == "CMU-TimeSeries") %>%
  arrange(desc(mean_wis)) %>% pull(geo_value)
plotting_forecasts(plotting_window = this_week - 12 * 7, score_window = 8, geo_score_order, n_plotting = 5)
```



## All by WIS
```{r plotting_all_raw_wis_recent_forecasts, out.width="300%", fig.dim=c(12,60), fig.align = "center", message=FALSE}
geo_score_order <- scores %>%
  filter(forecast_date > this_week - score_window * 7) %>%
  scores_by_state() %>%
  filter(forecaster == "CMU-TimeSeries") %>%
  arrange(desc(mean_wis)) %>% pull(geo_value)
plotting_forecasts(plotting_window = this_week - 12 * 7, score_window = 8, geo_score_order, n_plotting = 60)
```
