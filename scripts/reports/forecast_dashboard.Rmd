---
title: "Disease Surveillance Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
library(tidyverse)
library(httr)
library(lubridate)
library(progress)
library(targets)
source(here::here("R", "load_all.R"))

options(readr.show_progress = FALSE)
options(readr.show_col_types = FALSE)
insufficient_data_geos <- c("as", "mp", "vi", "gu")


config <- list(
    base_url = "https://raw.githubusercontent.com/cdcepi/FluSight-forecast-hub/main/model-output",
    forecasters = c(
        "CMU-TimeSeries", "FluSight-baseline", "FluSight-ensemble",
        "FluSight-base_seasonal", "UMass-flusion"
    )
)

# Function to fetch NHSN data
get_nhsn_data <- function() {
    if (wday(Sys.Date()) < 6 & wday(Sys.Date()) > 3) {
        # download from the preliminary data source from Wednesday to Friday
        most_recent_result <- readr::read_csv("https://data.cdc.gov/resource/mpgq-jmmr.csv?$limit=20000&$select=weekendingdate,jurisdiction,totalconfc19newadm,totalconfflunewadm")
    } else {
        most_recent_result <- readr::read_csv("https://data.cdc.gov/resource/ua7e-t2fy.csv?$limit=20000&$select=weekendingdate,jurisdiction,totalconfc19newadm,totalconfflunewadm")
    }
    most_recent_result %>%
        process_nhsn_data() %>%
        filter(disease == "nhsn_flu") %>%
        select(-disease) %>%
        filter(geo_value %nin% insufficient_data_geos) %>%
        mutate(
            source = "nhsn",
            geo_value = ifelse(geo_value == "usa", "us", geo_value),
            time_value = time_value
        ) %>%
        filter(version == max(version)) %>%
        select(-version) %>%
        data_substitutions(disease = "flu") %>%
        as_epi_df(other_keys = "source", as_of = Sys.Date())
}

# Function to fetch forecasts
get_forecasts <- function(days_back = 120) {
    end_date <- Sys.Date()
    start_date <- end_date - days_back
    dates <- seq(get_reference_date(start_date), end_date, by = "week")

    all_forecasts <- map(config$forecasters, function(forecaster) {
        map(dates, function(date) {
            filename <- paste0(format(date, "%Y-%m-%d"), "-", forecaster, ".csv")
            url <- paste0(config$base_url, "/", forecaster, "/", filename)

            tryCatch(
                {
                    response <- GET(url)
                    if (status_code(response) == 200) {
                        read_csv(url, col_types = list(
                            reference_date = col_date(format = "%Y-%m-%d"),
                            target_end_date = col_date(format = "%Y-%m-%d"),
                            target = col_character(),
                            location = col_character(),
                            horizon = col_integer(),
                            output_type = col_character(),
                            output_type_id = col_character(),
                            value = col_double(),
                            forecaster = col_character(),
                            forecast_date = col_date(format = "%Y-%m-%d")
                        )) %>%
                            mutate(
                                forecaster = forecaster,
                                forecast_date = as.Date(date)
                            )
                    }
                },
                error = function(e) NULL
            )
        }) %>%
            bind_rows()
    }) %>%
        bind_rows() %>%
        add_state_info(geo_value_col = "location", old_geo_code = "state_code", new_geo_code = "state_id")

    return(all_forecasts)
}

score_forecasts <- function(all_forecasts, nhsn_latest_data) {
    predictions_cards <- all_forecasts %>%
        rename(model = forecaster) %>%
        mutate(
            quantile = as.numeric(output_type_id),
            prediction = value
        ) %>%
        select(model, geo_value, forecast_date, target_end_date, quantile, prediction)

    truth_data <- nhsn_latest_data %>%
        mutate(
            target_end_date = as.Date(time_value),
            true_value = value
        ) %>%
        select(geo_value, target_end_date, true_value)

    evaluate_predictions(predictions_cards = predictions_cards, truth_data = truth_data) %>%
        rename(forecaster = model)
}

# Fetch all data
nhsn_latest_data <- get_nhsn_data()

# Create NHSN archive
nhsn_archive_data <- create_nhsn_data_archive(disease = "nhsn_flu")

# Fetch forecasts
all_forecasts_unfiltered <- get_forecasts(days_back = 120)
all_forecasts <- all_forecasts_unfiltered %>%
    filter(
        target == "wk inc flu hosp",
        output_type == "quantile"
    ) %>%
    mutate(
        geo_value = state_id
    ) %>%
    select(-location)

# Score forecasts
all_scores <- score_forecasts(all_forecasts, nhsn_data)
```

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(plotly)
library(shiny)
library(DT)
library(epiprocess)

# Setup the data
nhsn_data <- nhsn_latest_data
nhsn_historical <- nhsn_archive_data
forecast_data <- all_forecasts %>%
    filter(output_type_id %in% c("0.05", "0.5", "0.95")) %>%
    pivot_wider(names_from = output_type_id, values_from = value)
scores_data <- all_scores

# Pre-compute the historical data as-of each forecast date
unique_forecast_dates <- sort(unique(forecast_data$forecast_date))
nhsn_historical_as_ofs <- map(unique_forecast_dates, ~ {
    nhsn_historical %>%
        epix_as_of(as.Date(.x)) %>%
        mutate(time_value = time_value)
})
```

# Column {.sidebar data-width=300}

```{r}
# Location selector
selectInput("location", "Select Location",
    choices = unique(nhsn_data$geo_value),
    selected = "us"
)

# Date range for historical data
dateRangeInput("date_range", "Select Date Range",
    start = as.Date("2023-07-01"),
    end = max(nhsn_data$time_value),
    max = max(nhsn_data$time_value)
)

# Add checkboxes for forecaster selection
checkboxGroupInput("forecasters", "Select Forecasters:",
    choices = unique(forecast_data$forecaster),
    selected = c("FluSight-ensemble", "CMU-TimeSeries")
)

div(
    style = "text-align: center;",
    p("Forecast Date"),
    div(
        style = "display: inline-block;",
        actionButton("prev_date", "←"),
        actionButton("next_date", "→")
    ),
    textOutput("current_forecast_date")
)

current_date_index <- reactiveVal(length(unique_forecast_dates))

observeEvent(input$next_date, {
    current_date_index(min(length(unique_forecast_dates), current_date_index() + 1))
})

observeEvent(input$prev_date, {
    current_date_index(max(1, current_date_index() - 1))
})

output$current_forecast_date <- renderText({
    unique_forecast_dates[current_date_index()]
})

# Throttole to avoid re-computing the plot too often
plot_inputs <- reactive({
    list(
        location = input$location,
        date_range = input$date_range,
        forecasters = input$forecasters,
        forecast_date = unique_forecast_dates[current_date_index()]
    )
}) %>% debounce(500)

plot_result <- reactive({
    req(plot_inputs())
    inputs <- plot_inputs()

    data_subset <- forecast_data %>%
        filter(
            forecaster %in% input$forecasters,
            forecast_date == inputs$forecast_date,
            geo_value == inputs$location
        )

    # Base data (light grey)
    p <- ggplot() +
        geom_line(
            data = nhsn_data %>%
                filter(
                    geo_value == inputs$location,
                    inputs$date_range[1] <= time_value,
                    time_value <= inputs$date_range[2]
                ),
            aes(x = time_value, y = value),
            color = "grey80"
        ) +

        # As-of data (black)
        geom_line(
            data = nhsn_historical_as_ofs[[current_date_index()]] %>%
                filter(
                    geo_value == inputs$location,
                    inputs$date_range[1] <= time_value,
                    time_value <= inputs$date_range[2]
                ),
            aes(x = time_value, y = value),
            color = "black"
        ) +

        # Median line
        geom_line(
            data = data_subset,
            aes(x = target_end_date, y = .data$`0.5`, color = forecaster)
        ) +

        # Confidence interval
        geom_ribbon(
            data = data_subset,
            aes(
                x = target_end_date,
                ymin = .data$`0.05`,
                ymax = .data$`0.95`,
                fill = forecaster
            ),
            alpha = 0.5
        ) +
        theme_minimal() +
        labs(
            x = "Date", y = "Hospitalizations",
            title = paste("Disease Surveillance for", toupper(inputs$location))
        )

    ggplotly(p)
}) %>% bindCache(plot_inputs())
```

# Forecast Fan Plots {data-width=750}

```{r}
renderPlotly({
    plot_result()
})
```

# Performance Metrics {data-width=350}

```{r}
renderDT({
    # Calculate performance metrics for selected forecaster
    performance_metrics <- scores_data %>%
        filter(
            geo_value == input$location
        ) %>%
        group_by(ahead, forecaster) %>%
        summarise(
            wis = round(mean(wis), 2),
            ae = round(mean(ae), 2),
            coverage_80 = round(mean(coverage_80), 2)
        ) %>%
        ungroup() %>%
        arrange(ahead, wis)

    datatable(performance_metrics,
        options = list(
            pageLength = 50,
            scrollY = TRUE
        )
    )
})
```
