---
title: Evaluation of Hospitalization Forecasters 2024-2025
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: hide
editor_options:
  chunk_output_type: console
---

$$\\[.4in]$$

```{r echo=FALSE}
knitr::opts_chunk$set(
    fig.align = "center",
    message = FALSE,
    warning = FALSE,
    cache = FALSE
)
ggplot2::theme_set(ggplot2::theme_bw())
```

```{r}
library(aws.s3)
library(data.table)
library(dplyr)
library(DT)
library(ggplot2)
library(plotly)
library(readr)
library(stringr)
library(tidyr)
library(purrr)
```

```{r}
# Load the table of parameter combinations
s3load("flu_2023_forecaster_parameter_combinations.rds", bucket = "forecasting-team-data")
s3load("flu_2023_joined_scores.rds", bucket = "forecasting-team-data")

# Select forecasters for this notebook
outside_forecasters <- c("FluSight-baseline", "FluSight-ensemble")
id_to_forecaster <- forecaster_parameter_combinations_ %>%
    purrr::imap(\(x, idx) {
        x %>% mutate(family_name = idx)
    }) %>%
    bind_rows() %>%
    select(id, forecaster, family_name) %>%
    rename(forecaster_function = forecaster)

Mean <- function(x) mean(x, na.rm = TRUE)
GeoMean <- function(x, offset = 0) exp(Mean(log(x + offset)))

overall_rating <- flu_2023_joined_scores %>%
    group_by(forecaster) %>%
    summarize(mean_score = Mean(wis)) %>%
    filter(mean_score > 20) %>%
    arrange(mean_score) %>%
    left_join(id_to_forecaster, by = join_by(forecaster == id))
best_in_class <- overall_rating %>%
    group_by(family_name) %>%
    filter(row_number() == 1) %>%
    pull(forecaster)
forecasters_to_keep <- c(best_in_class, outside_forecasters) %>% unique()
# Load forecasts and scores
scores <- flu_2023_joined_scores %>%
    filter(forecaster %in% forecasters_to_keep)
forecast_dates <- scores %>%
    pull(forecast_date) %>%
    unique()
forecasters <- best_in_class
aheads <- scores %>%
    pull(ahead) %>%
    unique()
base_forecaster_name <- "FluSight-baseline"
```

### Notebook Information

#### Forecaster Family

Best examples from each family of forecasters

#### Target Dates

`r forecast_dates`

#### Forecaster Parameter Mapping and Overall Scores

The table is sorted by ascending WIS and contains all the forecasters in this notebook.

```{r}
# Display the table
forecasters_to_keep
param_table <- forecaster_parameter_combinations_ %>%
    map(\(x) x %>%
        filter(id %in% forecasters_to_keep)) %>%
    bind_rows() %>%
    left_join(id_to_forecaster, by = join_by(id)) %>%
    select(-any_of(c("forecaster", "keys_to_ignore", "pop_scaling"))) %>%
    {
        if ("n_training" %in% colnames(.)) {
            (.) %>% mutate(n_training = as.character(n_training))
        } else {
            .
        }
    } %>%
    full_join(
        scores %>%
            group_by(forecaster) %>%
            summarize(
                mean_ae = round(Mean(ae), 2),
                geomean_ae = round(GeoMean(ae), 2),
                mean_wis = round(Mean(wis), 2),
                geomean_wis = round(GeoMean(wis), 2),
                mean_coverage_80 = round(Mean(coverage_80), 2),
            ) %>%
            rename(id = forecaster)
    ) %>%
    arrange(mean_ae) %>%
    relocate(family = family_name, id, mean_ae, geomean_ae, mean_wis, geomean_wis, mean_coverage_80)
datatable(param_table)
```

$$\\[.07in]$$

### Score Plots {.tabset}

- The WIS plots are relative to the FluSight-baseline. These plots are aggregated with the geometric mean.
- The absolute error plots are also relative to the FluSight-baseline, but are aggregated with the arithmetic mean.
- The dashed black line in all plots is the FluSight-ensemble.

#### WIS by Forecast Date

```{r}
var <- "wis"
group_cols <- c("forecaster", "forecast_date", "ahead")

# Aggregate metric across groups
df <- scores %>%
    select(all_of(c(group_cols, var))) %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := GeoMean(!!sym(var)), .by = all_of(group_cols)) %>%
    filter(ahead >= 0)

# Make sure we don't divide by zero
if (
    df %>%
        filter(forecaster == base_forecaster_name & near(!!sym(var), 0)) %>%
        nrow() > 0
) {
    warning("scale_by_forecaster will divide by zero in column ", var)
}

# Normalize the metric by the baseline
normalized_df <- df %>%
    pivot_wider(names_from = forecaster, names_prefix = var, values_from = !!sym(var)) %>%
    mutate(across(starts_with(var), ~ .x / !!sym(paste0(var, base_forecaster_name)))) %>%
    pivot_longer(cols = starts_with(var), names_to = "forecaster", values_to = var) %>%
    mutate(forecaster = stringr::str_remove(forecaster, var)) %>%
    filter(forecaster != base_forecaster_name)

facets.label <- str_glue("{aheads} days ahead")
names(facets.label) <- aheads
subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    normalized_df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = forecast_date, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = 1, linetype = 1, color = "black") +
    facet_grid(rows = vars(ahead)) +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    scale_y_log10(n.breaks = 10) +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Forecast Dates", y = "Geometric Mean WIS")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### WIS by Ahead

```{r}
var <- "wis"
group_cols <- c("forecaster", "ahead")

# Aggregate metric across groups
df <- scores %>%
    select(all_of(c(group_cols, var))) %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := GeoMean(!!sym(var)), .by = all_of(group_cols)) %>%
    filter(ahead >= 0)

# Make sure we don't divide by zero
if (df %>% filter(forecaster == base_forecaster_name & near(!!sym(var), 0)) %>% nrow() > 0) {
    warning("scale_by_forecaster will divide by zero in column ", var)
}

# Normalize the metric by the baseline
normalized_df <- df %>%
    pivot_wider(names_from = forecaster, names_prefix = var, values_from = !!sym(var)) %>%
    mutate(across(starts_with(var), ~ .x / !!sym(paste0(var, base_forecaster_name)))) %>%
    pivot_longer(cols = starts_with(var), names_to = "forecaster", values_to = var) %>%
    mutate(forecaster = stringr::str_remove(forecaster, var)) %>%
    filter(forecaster != base_forecaster_name)

subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    normalized_df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = ahead, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = 1, linetype = 1, color = "black") +
    scale_y_log10(n.breaks = 20) +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Days ahead", y = "Geometric Mean WIS")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### Absolute Error by Forecast Date

```{r}
var <- "ae"
group_cols <- c("forecaster", "forecast_date", "ahead")

# Aggregate metric across groups
df <- scores %>%
    select(all_of(c(group_cols, var))) %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := Mean(!!sym(var)), .by = all_of(group_cols)) %>%
    filter(ahead >= 0)

# Make sure we don't divide by zero
if (
    df %>%
        filter(forecaster == base_forecaster_name & near(!!sym(var), 0)) %>%
        nrow() > 0
) {
    warning("scale_by_forecaster will divide by zero in column ", var)
}

# Normalize the metric by the baseline
normalized_df <- df %>%
    pivot_wider(names_from = forecaster, names_prefix = var, values_from = !!sym(var)) %>%
    mutate(across(starts_with(var), ~ .x / !!sym(paste0(var, base_forecaster_name)))) %>%
    pivot_longer(cols = starts_with(var), names_to = "forecaster", values_to = var) %>%
    mutate(forecaster = stringr::str_remove(forecaster, var)) %>%
    filter(forecaster != base_forecaster_name)

facets.label <- str_glue("{aheads} days ahead")
names(facets.label) <- aheads
subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    normalized_df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = forecast_date, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = 1, linetype = 1, color = "black") +
    facet_grid(rows = vars(ahead)) +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    scale_y_log10(n.breaks = 10) +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Forecast Dates", y = "Mean Absolute Error")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### Absolute Error by Ahead

```{r}
var <- "ae"
group_cols <- c("forecaster", "ahead")

# Aggregate metric across groups
df <- scores %>%
    select(all_of(c(group_cols, var))) %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := Mean(!!sym(var)), .by = all_of(group_cols)) %>%
    filter(ahead >= 0)

# Make sure we don't divide by zero
if (df %>% filter(forecaster == base_forecaster_name & near(!!sym(var), 0)) %>% nrow() > 0) {
    warning("scale_by_forecaster will divide by zero in column ", var)
}

# Normalize the metric by the baseline
normalized_df <- df %>%
    pivot_wider(names_from = forecaster, names_prefix = var, values_from = !!sym(var)) %>%
    mutate(across(starts_with(var), ~ .x / !!sym(paste0(var, base_forecaster_name)))) %>%
    pivot_longer(cols = starts_with(var), names_to = "forecaster", values_to = var) %>%
    mutate(forecaster = stringr::str_remove(forecaster, var)) %>%
    filter(forecaster != base_forecaster_name)

subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    normalized_df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = ahead, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = normalized_df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = 1, linetype = 1, color = "black") +
    scale_y_log10(n.breaks = 25) +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Days ahead", y = "Mean Absolute Error")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### % Coverage by Forecast Date

```{r}
var <- "coverage_80"
group_cols <- c("forecaster", "forecast_date", "ahead")

# Aggregate metric across groups
df <- scores %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := Mean(!!sym(var)), .by = all_of(group_cols)) %>%
    filter(ahead >= 0)

facets.label <- str_glue("{aheads} days ahead")
names(facets.label) <- aheads
subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = forecast_date, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = forecast_date, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = .8, linetype = 1, color = "black") +
    facet_grid(rows = vars(ahead)) +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Forecast Dates", y = "Mean 80% Coverage")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### % Coverage by Ahead

```{r}
var <- "coverage_80"
id_cols <- c("forecaster", "ahead")

# Aggregate metric across groups
df <- scores %>%
    select(all_of(c(id_cols, var))) %>%
    drop_na(!!sym(var)) %>%
    summarize(!!var := Mean(!!sym(var)), .by = all_of(id_cols)) %>%
    filter(ahead >= 0)

subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)
p <- ggplot(
    df %>% filter(forecaster != "FluSight-ensemble"),
    aes(x = ahead, y = !!sym(var))
) +
    geom_line(aes(color = forecaster, group = forecaster)) +
    geom_point(aes(color = forecaster, group = forecaster)) +
    geom_line(
        data = df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", linetype = 2
    ) +
    geom_point(
        data = df %>% filter(forecaster == "FluSight-ensemble"),
        aes(x = ahead, y = !!sym(var)),
        color = "black", shape = 21, fill = "white"
    ) +
    geom_hline(yintercept = .8, linetype = 1, color = "black") +
    scale_color_discrete() +
    guides(color = guide_legend(ncol = 2)) +
    labs(title = subtitle, x = "Days ahead", y = "Mean 80% Coverage")

ggplotly(p, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

### Fan plots {.tabset}

Fan plots showing the 80% prediction intervals for the forecasts made by the CMU forecasters and the outside forecasters. The black line is the truth data.

#### Large States
```{r}
# Load the forecasts and the truth data
s3load(object = "flu_2023_joined_forecasts.rds", bucket = "forecasting-team-data")
s3load(object = "flu_2023_truth_data.rds", bucket = "forecasting-team-data")
# We plot a subset of the dates and geos for the fan plot
plot_dates <- seq.Date(as.Date("2023-10-07"), by = "4 weeks", length.out = 8)
geo_vals <- c("ca", "fl", "pa", "tx", "ny")
forecast_subset <- flu_2023_joined_forecasts %>%
    filter(
        forecaster %in% forecasters_to_keep,
        geo_value %in% geo_vals,
        forecast_date %in% plot_dates
    ) %>%
    mutate(quantile = as.character(quantile)) %>%
    pivot_wider(names_from = "quantile", values_from = "prediction") %>%
    mutate(ahead = as.numeric(target_end_date - forecast_date))


p <- ggplot(
    data = forecast_subset,
    aes(x = target_end_date, group = forecast_date)
) +
    geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`, fill = forecast_date), alpha = 0.3) +
    geom_line(aes(y = `0.5`, color = forecast_date), linetype = 2L) +
    geom_point(aes(y = `0.5`, color = forecast_date), size = 0.75) +
    geom_line(
        data = flu_2023_truth_data %>% filter(geo_value %in% geo_vals),
        aes(x = target_end_date, y = true_value),
        inherit.aes = FALSE, na.rm = TRUE,
        color = "black", linetype = 1
    ) +
    scale_y_continuous(n.breaks = 15) +
    facet_grid(factor(forecaster, levels = param_table$id) ~ geo_value, scales = "free") +
    labs(x = "Reference Date", y = "Weekly Sums of Hospitalizations", title = "Monthly Forecasts and Truth Data") +
    theme(legend.position = "none")


ggplotly(p, tooltip = "text", height = 300 * length(param_table$id), width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### Medium States
```{r}
# Load the forecasts and the truth data
s3load(object = "flu_2023_joined_forecasts.rds", bucket = "forecasting-team-data")
s3load(object = "flu_2023_truth_data.rds", bucket = "forecasting-team-data")
# We plot a subset of the dates and geos for the fan plot
plot_dates <- seq.Date(as.Date("2023-10-07"), by = "4 weeks", length.out = 8)
geo_vals <- c("mn", "co", "ky", "md")
forecast_subset <- flu_2023_joined_forecasts %>%
    filter(
        forecaster %in% forecasters_to_keep,
        geo_value %in% geo_vals,
        forecast_date %in% plot_dates
    ) %>%
    mutate(quantile = as.character(quantile)) %>%
    pivot_wider(names_from = "quantile", values_from = "prediction") %>%
    mutate(ahead = as.numeric(target_end_date - forecast_date))


p <- ggplot(
    data = forecast_subset,
    aes(x = target_end_date, group = forecast_date)
) +
    geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`, fill = forecast_date), alpha = 0.3) +
    geom_line(aes(y = `0.5`, color = forecast_date), linetype = 2L) +
    geom_point(aes(y = `0.5`, color = forecast_date), size = 0.75) +
    geom_line(
        data = flu_2023_truth_data %>% filter(geo_value %in% geo_vals),
        aes(x = target_end_date, y = true_value),
        inherit.aes = FALSE, na.rm = TRUE,
        color = "black", linetype = 1
    ) +
    scale_y_continuous(n.breaks = 15) +
    facet_grid(factor(forecaster, levels = param_table$id) ~ geo_value, scales = "free") +
    labs(x = "Reference Date", y = "Weekly Sums of Hospitalizations", title = "Monthly Forecasts and Truth Data") +
    theme(legend.position = "none")


ggplotly(p, tooltip = "text", height = 300 * length(param_table$id), width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```
#### Small States
```{r}
# Load the forecasts and the truth data
s3load(object = "flu_2023_joined_forecasts.rds", bucket = "forecasting-team-data")
s3load(object = "flu_2023_truth_data.rds", bucket = "forecasting-team-data")
# We plot a subset of the dates and geos for the fan plot
plot_dates <- seq.Date(as.Date("2023-10-07"), by = "4 weeks", length.out = 8)
geo_vals <- c("nv", "vt", "de", "ri", "nm")
forecast_subset <- flu_2023_joined_forecasts %>%
    filter(
        forecaster %in% forecasters_to_keep,
        geo_value %in% geo_vals,
        forecast_date %in% plot_dates
    ) %>%
    mutate(quantile = as.character(quantile)) %>%
    pivot_wider(names_from = "quantile", values_from = "prediction") %>%
    mutate(ahead = as.numeric(target_end_date - forecast_date))


p <- ggplot(
    data = forecast_subset,
    aes(x = target_end_date, group = forecast_date)
) +
    geom_ribbon(aes(ymin = `0.1`, ymax = `0.9`, fill = forecast_date), alpha = 0.3) +
    geom_line(aes(y = `0.5`, color = forecast_date), linetype = 2L) +
    geom_point(aes(y = `0.5`, color = forecast_date), size = 0.75) +
    geom_line(
        data = flu_2023_truth_data %>% filter(geo_value %in% geo_vals),
        aes(x = target_end_date, y = true_value),
        inherit.aes = FALSE, na.rm = TRUE,
        color = "black", linetype = 1
    ) +
    scale_y_continuous(n.breaks = 15) +
    facet_grid(factor(forecaster, levels = param_table$id) ~ geo_value, scales = "free") +
    labs(x = "Reference Date", y = "Weekly Sums of Hospitalizations", title = "Monthly Forecasts and Truth Data") +
    theme(legend.position = "none")


ggplotly(p, tooltip = "text", height = 300 * length(param_table$id), width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```
