---
title: Evaluation of Hospitalization Forecasters
subtitle: Parameterized Report
date: "`r format(Sys.time(), '%d %B %Y')`"
abstract: |
  This notebook is a template for evaluating hospitalization forecasters.
output:
  html_document:
    code_folding: hide
editor_options:
  chunk_output_type: console
---

$$\\[.4in]$$

```{r echo=FALSE}
# Package installation
knitr::opts_chunk$set(
    fig.align = "center",
    message = FALSE,
    warning = FALSE,
    cache = TRUE
)
```

```{r}
source(here::here("R", "load_all.R"))
library(evalcast)
library(targets)
```

### Retrieving Forecast Data

The forecasts are expected to have a few columns:

- `ahead`: The number of days ahead the forecast is made
- `geo_value`: The geographic unit of the forecast
- `forecast_date`: The date the forecast was made
- `forecaster`: The name of the forecaster
- `target_end_date`: The date the forecast is predicting
- `actual`: The actual value of the target
- `wis`: The weighted interval score
- `ae`: The absolute error
- `cov_80`: The 80% coverage
- `data_source`: The data source of the forecast
- `signal`: The signal of the forecast
- `incidence_period`: The period of the forecast

```{r}
df <- targets::tar_manifest()
scores <- df %>%
    filter(stringr::str_detect(name, "score_")) %>%
    pull(name) %>%
    map(~ tibble(forecaster = str_remove(.x, "score_"), tar_read_raw(.x))) %>%
    bind_rows()

# TODO: First figure.
# TODO: Then fan plots of the forecasts.
```

**The target forecast dates are:** <br/> `r forecast_dates`

**The template will compile data of the following forecasters:** <br/> `r params$forecasters`.

**For this analysis, all of Logan's forecasters have been renamed:** <br/>

```{r renamed forecasters}
kableExtra::kbl(names_table) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
```

$$\\[.07in]$$

### Weighted Interval Score (relative to baseline) and 80% Coverage {.tabset}

* Move all forecasters to Monday (adjust ahead backward, forecast date forward)
* Maintains the target date
* Subset to forecast dates / aheads / geo_values that Logan forecast


#### WIS by Forecast Date (GeoMean)

```{r fd-wis}
Mean <- function(x) mean(x, na.rm = TRUE)
GeoMean <- function(x, offset = 0) exp(Mean(log(x + offset)))

facets.label <- str_glue("{aheads} days ahead")
names(facets.label) <- aheads

subtitle <- sprintf(
    "Forecasts made over %s to %s",
    format(min(forecast_dates), "%B %d, %Y"),
    format(max(forecast_dates), "%B %d, %Y")
)

plot_wis <- plot_canonical(results,
    x = "forecast_date",
    y = "wis",
    aggr = GeoMean,
    grp_vars = c("forecaster", "ahead"),
    facet_rows = "ahead", dots = FALSE,
    base_forecaster = "COVIDhub-baseline"
) +
    labs(
        title = subtitle,
        x = "Forecast Dates",
        y = "Geometric Mean WIS"
    ) +
    # geom_point(aes(forecast_date, round(wis, digits = 2), color)), alpha = 0.05) +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    scale_y_log10() +
    geom_hline(yintercept = 1, size = 1.5) +
    scale_color_viridis_d() +
    guides(color = guide_legend(ncol = 2))


ggplotly(plot_wis, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### WIS by Forecast Date (Mean)

```{r fd-wis-m}
plot_wis <-
    plot_canonical(results,
        x = "forecast_date",
        y = "wis",
        aggr = Mean,
        grp_vars = c("forecaster", "ahead"),
        facet_rows = "ahead", dots = FALSE,
        base_forecaster = "COVIDhub-baseline"
    ) +
    labs(
        title = subtitle,
        x = "Forecast Dates",
        y = "Geometric Mean WIS"
    ) +
    # geom_point(aes(forecast_date, round(wis, digits = 2), color)), alpha = 0.05) +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    scale_y_log10() +
    geom_hline(yintercept = 1, size = 1.5) +
    scale_color_viridis_d() +
    guides(color = guide_legend(ncol = 2))


ggplotly(plot_wis, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### WIS by Ahead (GeoMean)


```{r overall-wis}
plot_wis_a <-
    plot_canonical(results,
        x = "ahead",
        y = "wis",
        aggr = GeoMean,
        grp_vars = c("forecaster"),
        dots = TRUE,
        base_forecaster = "COVIDhub-baseline"
    ) +
    labs(
        title = subtitle,
        x = "Days ahead",
        y = "Geometric Mean WIS"
    ) +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    geom_hline(yintercept = 1, size = 1.5) +
    scale_y_log10() +
    scale_color_viridis_d() +
    guides(color = guide_legend(ncol = 2))


ggplotly(plot_wis_a, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```

#### WIS by Ahead (Mean)


``` {r overall-wis-m}
plot_wis_a <-
    plot_canonical(results,
        x = "ahead",
        y = "wis",
        aggr = GeoMean,
        grp_vars = c("forecaster"),
        dots = TRUE,
        base_forecaster = "COVIDhub-baseline"
    ) +
    labs(
        title = subtitle,
        x = "Days ahead",
        y = "Geometric Mean WIS"
    ) +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    geom_hline(yintercept = 1, size = 1.5) +
    scale_y_log10() +
    scale_color_viridis_d() +
    guides(color = guide_legend(ncol = 2))


ggplotly(plot_wis_a, tooltip = "text", height = 800, width = 1000) %>%
    layout(hoverlabel = list(bgcolor = "white"))
```



#### % Coverage by Forecast Date


``` {r fd-coverage80}
plot_cov80 <-
    plot_canonical(results,
        x = "forecast_date",
        y = "cov_80",
        aggr = mean,
        grp_vars = c("forecaster", "ahead"),
        facet_rows = "ahead",
        dots = FALSE
    ) +
    labs(title = subtitle, x = "Forecast date", y = "Mean Coverage 80") +
    facet_wrap(~ahead, nrow = 4, labeller = labeller(ahead = facets.label)) +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    scale_color_viridis_d() +
    geom_hline(yintercept = 0.8, size = 1.5) +
    guides(color = guide_legend(ncol = 2))

ggplotly(plot_cov80, tooltip = "text", height = 800, width = 1000)
```

#### % Coverage by Ahead

``` {r overall-coverage80}
plot_cov80_a <-
    plot_canonical(results,
        x = "ahead",
        y = "cov_80",
        aggr = mean,
        grp_vars = "forecaster",
        dots = TRUE
    ) +
    labs(title = subtitle, x = "Days ahead", y = "Mean Coverage 80") +
    theme_bw() +
    theme(
        plot.title = element_text(hjust = "center"),
        legend.position = "bottom",
        legend.title = element_blank()
    ) +
    scale_color_viridis_d() +
    geom_hline(yintercept = 0.8, size = 1.5) +
    guides(color = guide_legend(ncol = 2))

ggplotly(plot_cov80_a, tooltip = "text", height = 800, width = 1000)
```


### Maps {.tabset}

* WIS is scaled by population
* Then take Mean over all Forecast Dates and Aheads


```{r maps-processing, warning=FALSE}
library(sf)

results_intersect <- intersect_averagers(
    scores, c("forecaster"), c("forecast_date", "geo_value")
) %>%
    select(c("ahead", "geo_value", "forecaster", "forecast_date", "data_source", "signal", "target_end_date", "incidence_period", "actual", "wis", "ae", "cov_80"))

maps <- results_intersect %>%
    group_by(geo_value, forecaster) %>%
    summarise(
        wis = Mean(wis),
        cov_80 = Mean(cov_80)
    ) %>%
    left_join(animalia::state_population, by = "geo_value") %>%
    mutate(wis = wis / population * 1e5) %>%
    pivot_longer(c("wis", "cov_80"), names_to = "score") %>%
    group_by(score) %>%
    mutate(
        time_value = Sys.Date(),
        max = max(value), min = min(value)
    ) %>%
    group_by(forecaster, .add = TRUE)
keys <- maps %>% group_keys()
maps <- maps %>% group_split()

levs <- levels(maps[[1]]$score)

# for county prediction, set geo_type = "county"
maps <- purrr::map(
    maps,
    ~ as.covidcast_signal(
        .x,
        signal = .x$score[1],
        data_source = .x$forecaster[1],
        geo_type = "state"
    )
)

maps <- purrr::map2(
    maps, keys$score,
    ~ plot(.x,
        choro_col = scales::viridis_pal()(3),
        range = if (.y == "wis") c(.x$min[1], .x$max[1]) else c(0, 1)
    )
)
```

#### Mean Weighted Interval Score


```{r map-wis, fig.width=12, fig.height=8}
cowplot::plot_grid(plotlist = maps[keys$score == "wis"], ncol = 3)
```


#### Coverage 80


```{r map-cov80, fig.width=12, fig.height=8}
cowplot::plot_grid(plotlist = maps[keys$score == "cov_80"], ncol = 3)
```
