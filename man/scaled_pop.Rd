% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecaster_scaled_pop.R
\name{scaled_pop}
\alias{scaled_pop}
\title{example forecaster definition}
\usage{
scaled_pop(
  epi_data,
  outcome,
  extra_sources = "",
  ahead = 1,
  pop_scaling = TRUE,
  trainer = parsnip::linear_reg(),
  levels = covidhub_probs(),
  ...
)
}
\arguments{
\item{epi_data}{the actual data used}

\item{outcome}{the name of the target variable}

\item{extra_sources}{the name of any extra columns to use. This list could be
empty}

\item{ahead}{(this is relative to the \code{as_of} field of the \code{epi_df}, which is
likely \emph{not} the same as the \code{ahead} used by epipredict, which is relative
to the max time value of the \code{epi_df}. how to handle this is a modelling
question left up to each forecaster; see latency_adjusting.R for the
existing examples)}

\item{pop_scaling}{an example extra parameter unique to this forecaster}

\item{trainer}{an example extra parameter that is fairly common}

\item{levels}{The quantile levels to predict. Defaults to those required by
covidhub.}

\item{...}{it can also have any number of other parameters. In this case, the
\code{...} args are all inputs to \code{\link[epipredict:arx_args_list]{epipredict::arx_args_list}}.  Consult the
repository for existing parameter names so that your function will follow a
similar schema (e.g. \code{trainer}, while not strictly required, is a common
parameter, as are any of the \code{arx_args_list()} parameters) these parameters
should be ones that will store well in a data.table; if you need more
complicated parameters, it is better to store them in separate files, and
use the filename as the parameter.}
}
\description{
a forecaster is a function that takes in an epi_df, an outcome column name, a
list of extra columns, and an ahead, and produces a forecast with a
\code{target_end_date} that is \code{ahead} many days after
\code{attributes(epi_df)$metadata$as_of}. The resulting output should be a tibble
with columns \verb{(geo_value, forecast_date, target_end_date, quantile, value)}, preferably in that order.

To define a forecaster:
\enumerate{
\item first define any pre-epipredict steps (they should be operating on a
epi_df)
\item then define any post-epipredict steps (same)
\item then create the forecaster as a function, which must have the following
arguments:
}
}
\seealso{
some utilities for making forecasters: \link{format_storage},
\link{perform_sanity_checks}
}
