% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecaster_smoothed_scaled.R
\name{smoothed_scaled}
\alias{smoothed_scaled}
\title{predict on smoothed data and the standard deviation}
\usage{
smoothed_scaled(
  epi_data,
  outcome,
  extra_sources = "",
  ahead = 1,
  pop_scaling = TRUE,
  trainer = parsnip::linear_reg(),
  quantile_levels = covidhub_probs(),
  smooth_width = 7,
  smooth_cols = NULL,
  sd_width = 28,
  sd_mean_width = 14,
  sd_cols = NULL,
  ...
)
}
\arguments{
\item{epi_data}{the actual data used}

\item{outcome}{the name of the target variable}

\item{extra_sources}{the name of any extra columns to use. This list could be
empty}

\item{ahead}{(this is relative to the \code{as_of} field of the \code{epi_df}, which is
likely \emph{not} the same as the \code{ahead} used by epipredict, which is relative
to the max time value of the \code{epi_df}. how to handle this is a modelling
question left up to each forecaster; see latency_adjusting.R for the
existing examples)}

\item{pop_scaling}{bool; if \code{TRUE}, assume all numeric columns are on the
count scale and translate them to a rate scale for model fitting.
Predictions will be translated back to count scale. Any
\code{layer_residual_quantiles} (for non-\code{"quantile_reg"} \code{trainer}s) will be
done on the rate scale. When specifying predictor lags, note that rate
variables will use the same names as and overwrite the count variables.
Rates here will be counts per 100k population, based on
\code{epipredict::state_census}.}

\item{trainer}{optional; parsnip model specification to use for the core
fitting & prediction (the \code{spec} of the internal
\code{\link[epipredict:epi_workflow]{epipredict::epi_workflow}}).  Default is \code{parsnip::linear_reg()}.}

\item{quantile_levels}{The quantile levels to predict. Defaults to those}

\item{smooth_width}{the number of days over which to do smoothing. If \code{NULL},
then no smoothing is applied.}

\item{smooth_cols}{the names of the columns to smooth. If \code{NULL} it smooths
everything}

\item{sd_width}{the number of days over which to take a moving average of the
standard deviation. If \code{NULL}, the sd_width isn't included.}

\item{sd_mean_width}{to calculate the sd, we need a window size for the mean
used.}

\item{sd_cols}{the names of the columns to smooth. If \code{NULL} its includes
the sd of everything}

\item{...}{any additional arguments as used by \link{default_args_list}
required by covidhub.}
}
\description{
This is a variant of \code{scaled_pop}, which predicts on a smoothed version of
the data. Even if the target is smoothed when used as a /predictor/, as a
/target/ it still uses the raw value (this captures some of the noise).  It
also uses a rolling standard deviation as an auxillary signal, window of
withd \code{sd_width}, which by default is 28 days.
If you are using \code{sd_width}, you should restrict the lags on the \code{sd} to only
include \code{0}, so set your lags to be e.g. \code{list(c(0,7,14), c(0))}.
}
\seealso{
some utilities for making forecasters: \link{format_storage},
\link{sanitize_args_predictors_trainer}
}
